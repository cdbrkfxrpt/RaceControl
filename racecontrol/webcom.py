# RaceControl, a bidirectional CAN bus telemetry platform.
# Copyright (C) 2016 Florian Eich

# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at

#    http://www.apache.org/licenses/LICENSE-2.0

# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.

from flask import Flask
from flask import Response
from flask import render_template

import struct
import can
import threading
import multiprocessing


class GUICom:
    """Gets can.Message objects and parses them through the msgfilter necessary
    to create web interface suited CSV data.

    The GUICom class has a threadsafe and processsafe queue it pushes the
    generated message to and a can.BufferedReader object which is notified by
    other RaceControl objects with can.Message objects. It starts a thread
    which runs the web interface data generator.
    """
    def __init__(self, queue, msgfilter):
        self.queue = queue
        self.msgfilter = msgfilter

        self.buffer = can.BufferedReader()

        self.permsg = []
        for i in range(9):
            self.permsg.append(0)

        self._running = threading.Event()
        self._running.set()

        self._generator = threading.Thread(target=self._generate)
        self._generator.daemon = True

        self._generator.start()

    def _generate(self):
        """
        The generate method filters incoming can.Message objects through the
        messagefilter and pushes CSV formatted data to the queue.
        """
        unpackdict = {2: 'H', 4: 'f', 8: 'd'}
        while self._running.is_set():

            msg = self.buffer.get_message(0.5)
            if msg and msg.arbitration_id in self.msgfilter:

                for k, v in self.msgfilter[msg.arbitration_id].items():
                    start = v['start']
                    size = v['size']
                    end = start + size
                    if v['size'] > 1:
                        self.permsg[k] = (struct.unpack(unpackdict[size],
                                          msg.data[start:end])[0])
                    else:
                        self.permsg[k] = msg.data[start]

                self.queue.put(
                    'data: ' +
                    ','.join(str(el) for el in self.permsg) +
                    '\n\n\n'
                )


class WebCom:
    """Handles serving web content to the user.

    The WebCom class holds the Flask object which serves web content to the
    user. Therein defined are methods for route responses, which encode data
    from the WebCom object's message queue into a server-side event data string
    and pass it on to clients.
    """
    def __init__(self):
        self.app = Flask('racecontrol')
        self.subscriptions = []
        self.msgqueue = multiprocessing.Queue()

        @self.app.route('/')
        def data():
            """
            The data() method returns a template rendered by Flask/Jinja2 based
            on templates/data.html.
            """
            return render_template('data.html')

        @self.app.route('/subscribe')
        def subscribe():
            """
            The subscribe() method returns a Flask.Response object, which
            contains data in the form of a 'data: some_data\n\n' generated by
            the gen() method, which in turn gets messages from the webcom queue
            and yields them. The Response object also flags the data as
            'text/event-stream' mimetype for the browser to identify. The
            subscribe() method is called by the JavaScript script in
            static/js/raceflot.js, where it is attached to an EventSource,
            which is the JavaScript implementation of a server side event
            object.
            """
            def gen():
                self.subscriptions.append(0)
                try:
                    while True:
                        data = self.msgqueue.get(True)
                        if data:
                            print(data)
                        # for line in open('/home/flrn/sandbox/tests/gendata.csv'):
                        #     data = 'data: ' + line + '\n'
                            yield data
                except GeneratorExit:
                    self.subscriptions.remove(0)

            return Response(gen(), mimetype="text/event-stream")

        @self.app.route('/debug')
        def debug():
            return "Currently %s self.subscriptions." % len(self.subscriptions)
