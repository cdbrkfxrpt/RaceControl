# RaceControl, a bidirectional CAN bus telemetry platform.
# Copyright (C) 2016 Florian Eich

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.


from flask import Flask
from flask import Response
from flask import render_template

import struct
import can
import threading
import multiprocessing


class GUICom:
    """Gets can.Message objects and parses them through the msgfilter necessary
    to create web interface suited CSV data.

    The GUICom class has a threadsafe and processsafe queue it pushes the
    generated message to and a can.BufferedReader object which is notified by
    other RaceControl objects with can.Message objects. It starts a thread
    which runs the web interface data generator.
    """
    def __init__(self, queue, msgfilter):
        self.queue = queue
        self.msgfilter = msgfilter

        self.buffer = can.BufferedReader()

        self.permsg = []
        for i in range(9):
            self.permsg.append(0)

        self._running = threading.Event()
        self._running.set()

        self._generator = threading.Thread(target=self._generate)
        self._generator.daemon = True

        self._generator.start()

    def _generate(self):
        """
        The generate method filters incoming can.Message objects through the
        messagefilter and pushes CSV formatted data to the queue.
        """
        unpackdict = {2: 'H', 4: 'f', 8: 'd'}
        while self._running.is_set():

            msg = self.buffer.get_message(0.5)
            if msg and msg.arbitration_id in self.msgfilter:

                for k, v in self.msgfilter[msg.arbitration_id].items():
                    start = v['start']
                    size = v['size']
                    end = start + size
                    if v['size'] > 1:
                        self.permsg[k] = (struct.unpack(unpackdict[size],
                                          msg.data[start:end])[0])
                    else:
                        self.permsg[k] = msg.data[start]

                self.queue.put(
                    'data: ' +
                    ','.join(str(el) for el in self.permsg) +
                    '\n\n\n'
                )


class WebCom:
    """Handles serving web content to the user.

    The WebCom class holds the Flask object which serves web content to the
    user. Therein defined are methods for route responses, which encode data
    from the WebCom object's message queue into a server-side event data string
    and pass it on to clients.
    """
    def __init__(self):
        self.app = Flask('racecontrol')
        self.subscriptions = []
        self.msgqueue = multiprocessing.Queue()

        @self.app.route('/')
        def data():
            """
            The data() method returns a template rendered by Flask/Jinja2 based
            on templates/data.html.
            """
            return render_template('data.html')

        @self.app.route('/subscribe')
        def subscribe():
            """
            The subscribe() method returns a Flask.Response object, which
            contains data in the form of a 'data: some_data\n\n' generated by
            the gen() method, which in turn gets messages from the webcom queue
            and yields them. The Response object also flags the data as
            'text/event-stream' mimetype for the browser to identify. The
            subscribe() method is called by the JavaScript script in
            static/js/raceflot.js, where it is attached to an EventSource,
            which is the JavaScript implementation of a server side event
            object.
            """
            def gen():
                self.subscriptions.append(0)
                try:
                    while True:
                        data = self.msgqueue.get(True)
                        if data:
                            print(data)
                            yield data
                except GeneratorExit:
                    self.subscriptions.remove(0)

            return Response(gen(), mimetype="text/event-stream")

        @self.app.route('/debug')
        def debug():
            return "Currently %s self.subscriptions." % len(self.subscriptions)
