#!/usr/bin/python3
# -*- coding: utf-8 -*-

# RaceControl, a bidirectional CAN bus telemetry platform.
# Copyright (C) 2016 Florian Eich

# This program is free software: you can redistribute it and/or modify
# it under the terms of the GNU General Public License as published by
# the Free Software Foundation, either version 3 of the License, or
# (at your option) any later version.

# This program is distributed in the hope that it will be useful,
# but WITHOUT ANY WARRANTY; without even the implied warranty of
# MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
# GNU General Public License for more details.

# You should have received a copy of the GNU General Public License
# along with this program.  If not, see <http://www.gnu.org/licenses/>.

import sys
import os
import canmatrix.importany as im
import gevent.wsgi as wsgi

import racecontrol.logcom as logcom
import racecontrol.netcom as netcom
import racecontrol.cancom as cancom
import racecontrol.webcom as webcom


def main():
    print(
        """
        RaceControl  Copyright (C) 2016  Florian Eich
        This program comes with ABSOLUTELY NO WARRANTY.
        This is free software, and you are welcome to
        redistribute it under certain conditions; see
        GPLv3 for details.
        """
    )

    # configpath = os.path.expanduser('~/.config/racecontrol')
    configpath = '/home/flrn/.config/racecontrol'
    if not os.path.exists(configpath):
        print('No config path found.')
        sys.exit(0)

    blacklistdbc = im.importany(configpath + '/dbc/blacklist.dbc')
    # prioritydbc = im.importany(configpath + '/dbc/priority.dbc')
    guiupperdbc = im.importany(configpath + '/dbc/guiupper.dbc')
    guilowerdbc = im.importany(configpath + '/dbc/guilower.dbc')
    guitextdbc = im.importany(configpath + '/dbc/guitext.dbc')

    blacklist = [frame._Id for frame in blacklistdbc._fl._list]

    uppersignals = guiupperdbc._fl._list[0]._signals
    guiupper = [guiupperdbc._fl._list[0]._Id]
    for sig in uppersignals:
        guiupper.append(int(sig._startbit / 8))
        guiupper.append(int(sig._signalsize / 8))
    print(guiupper)

    lowersignals = guilowerdbc._fl._list[0]._signals
    guilower = [guilowerdbc._fl._list[0]._Id]
    for sig in lowersignals:
        guilower.append(int(sig._startbit / 8))
        guilower.append(int(sig._signalsize / 8))
    print(guilower)

    textsignals = guitextdbc._fl._list[0]._signals
    guitext = [guitextdbc._fl._list[0]._Id]
    for sig in textsignals:
        guitext.append(int(sig._startbit / 8))
        guitext.append(int(sig._signalsize / 8))
    print(guitext)

    cancomd = cancom.CANCom(blacklist)
    netcomd = netcom.NetCom()
    logcomd = logcom.LogCom()
    webcomupper = webcom.GUIGenerator(webcom.upperqueue, guiupper)
    webcomlower = webcom.GUIGenerator(webcom.lowerqueue, guilower)
    webcomtext = webcom.GUIGenerator(webcom.textqueue, guitext)

    cancomd.add_listener(netcomd.dispatcher.buffer)
    cancomd.add_listener(webcomupper.buffer)
    cancomd.add_listener(webcomlower.buffer)
    cancomd.add_listener(webcomtext.buffer)
    netcomd.add_listener(cancomd.buffer)

    for listener in logcomd.loggers():
        cancomd.add_listener(listener)
        netcomd.add_listener(listener)

    # timestamp = time.perf_counter()
    try:
        webcom.app.debug = True
        server = wsgi.WSGIServer(("", 5000), webcom.app)
        server.serve_forever()
        # while True:
        #     if time.perf_counter() - timestamp > 1.0:
        #         # print('ConnectedRace running.')
        #         timestamp = time.perf_counter()
    except KeyboardInterrupt:
        print('\nExiting RaceControl.')
        sys.exit(0)

if __name__ == "__main__":
    main()
